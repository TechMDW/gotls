package main

import (
	"crypto/tls"
	"encoding/csv"
	"encoding/hex"
	"fmt"
	"net/http"
	"os"
	"strings"
	"text/template"
	"time"
)

type CipherSuite struct {
	Name        string
	Code        uint16
	DTLS        bool
	Recommended bool
	Reference   string
}

var cipherSuiteMap map[uint16]*tls.CipherSuite

func init() {
	cipherSuiteMap = make(map[uint16]*tls.CipherSuite)
	for _, c := range tls.CipherSuites() {
		cipherSuiteMap[c.ID] = c
	}
}

// Fownloads the CSV data from the given URL and returns it as a slice of records
func fetchCSV(url string, header bool) ([][]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	r := csv.NewReader(resp.Body)
	if header {
		r.Read()
	}
	records, err := r.ReadAll()
	if err != nil {
		return nil, err
	}

	return records, nil
}

// transformCipherCode takes a cipher suite code as a string (e.g., "0x13,0x04")
// and converts it to a uint16 value.
func transformCipherCode(code string) (uint16, error) {
	parts := strings.Split(strings.ReplaceAll(code, "0x", ""), ",")

	if len(parts) != 2 {
		return 0, fmt.Errorf("invalid format: %s", code)
	}

	bytes, err := hex.DecodeString(parts[0] + parts[1])
	if err != nil {
		return 0, err
	}

	return uint16(bytes[0])<<8 | uint16(bytes[1]), nil
}

// Generate constants and mapping for cipher suites
func generateCipherConstants(cipherSuites []CipherSuite) error {
	file, err := os.Create("cipher_suite.go")
	if err != nil {
		return err
	}
	defer file.Close()

	tmpl := `// Code generated by go run cmd/generate/main.go; DO NOT EDIT.
// This file was generated at {{ .Timestamp }}
package gotls

import (
	"strings"
	"crypto/tls"
)

type CipherSuiteCode uint16

type CipherSuite struct {
	Name        string
	Code        CipherSuiteCode
	DTLS        bool
	Recommended bool
	Reference   string
	GoReference *tls.CipherSuite
}

const (
	{{- range .CipherSuites}}
	// Reference: {{.Reference | linkReference}}
	//
	// Recommended: {{.Recommended}} 
	//
	// DTLS: {{.DTLS}}
	{{.Name | cleanName}} CipherSuiteCode = {{.Code}}
	{{- end}}
)

var CipherSuiteMap = map[CipherSuiteCode]CipherSuite{
	{{- range .CipherSuites}}
	{{.Name | cleanName}}: {
		Name:        "{{.Name}}",
		Code:        {{.Name | cleanName}},
		DTLS:        {{.DTLS}},
		Recommended: {{.Recommended}},
		Reference:   "{{.Reference}}",
		GoReference: {{.Code | goCipherSuite}},
	},
	{{- end}}
}

func (c CipherSuiteCode) String() string {
	return CipherSuiteMap[c].Name
}

func (c CipherSuiteCode) Uint16() uint16 {
	return uint16(c)
}

func Get(code uint16) *CipherSuite {
	if v, ok := CipherSuiteMap[CipherSuiteCode(code)]; ok {
		return &v
	}
	return nil
}

func GetByName(name string) *CipherSuite {
	for _, v := range CipherSuiteMap {
		if strings.EqualFold(v.Name, name) {
			return &v
		}
	}
	return nil
}

`

	t := template.Must(template.New("constants").Funcs(template.FuncMap{
		"cleanName": func(s string) string {
			return strings.Map(func(r rune) rune {
				if r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9' {
					return r
				}
				return '_'
			}, s)
		},
		"linkReference": func(s string) string {
			refs := strings.Split(strings.ReplaceAll(s, "][", " "), " ")
			var links []string

			for _, ref := range refs {
				trimmedRef := strings.Trim(ref, "[]")
				if trimmedRef != "" {
					links = append(links, fmt.Sprintf("https://datatracker.ietf.org/doc/html/%s", trimmedRef))
				}
			}

			return strings.Join(links, " ")
		},
		"goCipherSuite": func(cs uint16) string {
			cipher, ok := cipherSuiteMap[cs]
			if !ok {
				return "nil"
			}

			// Bit of a hack to get the tls.CipherSuite struct
			var b strings.Builder
			b.WriteString("&tls.CipherSuite{")
			fmt.Fprintf(&b, "ID:%d,", cipher.ID)
			fmt.Fprintf(&b, "Name:\"%s\",", cipher.Name)
			fmt.Fprintf(&b, "SupportedVersions:%#v,", cipher.SupportedVersions)
			fmt.Fprintf(&b, "Insecure:%t", cipher.Insecure)
			b.WriteString("}")

			return b.String()
		},
	}).Parse(tmpl))

	type data struct {
		Timestamp    string
		CipherSuites []CipherSuite
	}

	timestamp := time.Now().UTC().String()

	err = t.Execute(file, data{
		Timestamp:    timestamp,
		CipherSuites: cipherSuites,
	})
	if err != nil {
		return err
	}

	return nil
}

func main() {
	url := "https://www.iana.org/assignments/tls-parameters/tls-parameters-4.csv"
	records, err := fetchCSV(url, true)
	if err != nil {
		fmt.Println("Error fetching CSV:", err)
		return
	}

	var cipherSuites []CipherSuite
	for _, record := range records {
		// Skip records that don't have a Recommended flag or DTLS flag
		if len(record[2]) == 0 || len(record[3]) == 0 {
			continue
		}
		// Skip if reserved
		if record[1] == "Reserved" {
			continue
		}

		code, err := transformCipherCode(record[0])
		if err != nil {
			fmt.Println("Error transforming cipher code:", err)
			continue
		}

		cipherSuites = append(cipherSuites, CipherSuite{
			Name:        record[1],
			Code:        code,
			DTLS:        record[2] == "Y",
			Recommended: record[3] == "Y",
			Reference:   record[4],
		})
	}

	err = generateCipherConstants(cipherSuites)
	if err != nil {
		fmt.Println("Error generating cipher constants:", err)
	}
}
